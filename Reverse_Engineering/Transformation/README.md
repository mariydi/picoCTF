UTF-8を勉強させてくれる問題。
解放は色んなところにいっぱい乗っている。

UTF-8は、1～4バイトの可変長である。
encファイルはUTF-8で記載されている。

次に、問題文のコードを見る。

```python
 ''.join([chr((ord(flag[i]) << 8) + ord(flag[i + 1])) for i in range(0, len(flag), 2)])
```

n文字目のフラッグの値を8ビット左にシフトしたあと、
n+1文字目のフラッグの値を足して、それをchr()で文字に戻している。

出来上がるのは8ビットに8ビットを足した16ビットの値の文字列。
それを、フラッグ全体に実行するとencファイルの中の文字列が出てくる。

## デコード
まずは1文字目を見ていく。
文字だけでは言ってる意味がわからなかったので、デバッグ機能を使って見る。

1文字目はバイナリで以下のようになっていることがわかる。
```
'0b111000001101001'
```
先頭の0が見えないが、16ビットの値である。
つまり先頭8ビットの`01110000`は1文字目であることがわかる。
ということは、後ろ8ビットの`01101001`は2文字目であることもわかる。
なので、
- 8ビット右シフトしてあげると1文字目がでてくる。
- 後ろ8ビットだけ抜き出してやると2文字目がでてくる。
ということなので、それ用に組んでやる。

8ビット左シフトしたものがこれなので、右シフトは問題文を参考にできる。しなくてもいいけど。
後ろ8bitを抜き出すためには、8bit全部1の値とANDした返り値を取るのが一番手っ取り早い。
さっきのバイト列だと、以下のようになる。

- 8ビット右シフトしてあげると1文字目がでてくる。
  - '0b1110000'
- 後ろ8ビットだけ抜き出してやると2文字目がでてくる。
  - '0b1101001'

それぞれをchrでUTF8に戻してあげると復号できる。
あとは最後までそれをやってフラッグゲット。
